/* eslint-disable */
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
  /**
   * Get a sample org document for testing
   */
  async getSampleOrg(): Promise<OrgDocument> {
    return await TAURI_INVOKE("get_sample_org");
  },
  /**
   * Parse org document content
   */
  async parseOrgContent(content: string): Promise<Result<OrgDocument, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("parse_org_content", { content }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Run the datetime test program
   */
  async runDatetimeTest(): Promise<string> {
    return await TAURI_INVOKE("run_datetime_test");
  },
  /**
   * Start monitoring files based on user settings
   */
  async startFileMonitoring(): Promise<Result<string, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("start_file_monitoring"),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Stop file monitoring
   */
  async stopFileMonitoring(): Promise<Result<string, string>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("stop_file_monitoring") };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Get all documents from the repository
   */
  async getAllDocuments(): Promise<Result<OrgDocument[], string>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("get_all_documents") };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Get document by ID
   */
  async getOrgDocumentById(
    documentId: string,
  ): Promise<Result<OrgDocument | null, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("get_org_document_by_id", { documentId }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Get document display title by ID
   */
  async getOrgDocumentDisplayTitleById(
    documentId: string,
  ): Promise<Result<string, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("get_org_document_display_title_by_id", {
          documentId,
        }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Get document file path by ID
   */
  async getOrgDocumentPathById(
    documentId: string,
  ): Promise<Result<string, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("get_org_document_path_by_id", { documentId }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Load user settings
   */
  async loadUserSettings(): Promise<Result<UserSettings, string>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("load_user_settings") };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Save user settings
   */
  async saveUserSettings(
    settings: UserSettings,
  ): Promise<Result<null, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("save_user_settings", { settings }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Add a monitored path to settings
   */
  async addMonitoredPath(
    path: MonitoredPath,
  ): Promise<Result<UserSettings, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("add_monitored_path", { path }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Remove a monitored path from settings
   */
  async removeMonitoredPath(
    path: string,
  ): Promise<Result<UserSettings, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("remove_monitored_path", { path }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Update a monitored path in settings
   */
  async updateMonitoredPath(
    oldPath: string,
    newPath: MonitoredPath,
  ): Promise<Result<UserSettings, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("update_monitored_path", { oldPath, newPath }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Set whether a monitored path is enabled
   */
  async setPathEnabled(
    path: string,
    enabled: boolean,
  ): Promise<Result<UserSettings, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("set_path_enabled", { path, enabled }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Set parse override for a file
   */
  async setParseOverride(
    filePath: string,
    parse: boolean,
  ): Promise<Result<UserSettings, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("set_parse_override", { filePath, parse }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Remove parse override for a file
   */
  async removeParseOverride(
    filePath: string,
  ): Promise<Result<UserSettings, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("remove_parse_override", { filePath }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Clear all settings
   */
  async clearUserSettings(): Promise<Result<null, string>> {
    try {
      return { status: "ok", data: await TAURI_INVOKE("clear_user_settings") };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
  /**
   * Check if a file path is covered by current monitoring configuration
   */
  async checkPathMonitoringStatus(
    filePath: string,
  ): Promise<Result<boolean, string>> {
    try {
      return {
        status: "ok",
        data: await TAURI_INVOKE("check_path_monitoring_status", { filePath }),
      };
    } catch (e) {
      if (e instanceof Error) throw e;
      else return { status: "error", error: e as any };
    }
  },
};

/** user-defined events **/

/** user-defined constants **/

/** user-defined types **/

/**
 * Structure to represent a monitored path
 */
export type MonitoredPath = {
  /**
   * The path to monitor (file or directory)
   */
  path: string;
  /**
   * Type of the path (file or directory)
   */
  path_type: PathType;
  /**
   * Whether to monitor recursively (for directories)
   */
  recursive: boolean;
  /**
   * Whether this path is currently enabled
   */
  enabled: boolean;
};
/**
 * OrgDatetime represents a date/time in an org-mode file
 * This is similar to Orgize's Datetime but designed to be owned and serializable
 */
export type OrgDatetime = {
  year: number;
  month: number;
  day: number;
  dayname: string;
  hour: number | null;
  minute: number | null;
};
/**
 * Basic org-mode document structure
 */
export type OrgDocument = {
  id: string;
  title: string;
  content: string;
  headlines: OrgHeadline[];
  filetags: string[];
  file_path: string;
  properties: Partial<{ [key in string]: string }>;
  category: string;
  etag: string;
  todo_config: TodoConfiguration | null;
};
/**
 * Basic headline structure
 */
export type OrgHeadline = {
  id: string;
  document_id: string;
  title: OrgTitle;
  content: string;
  children: OrgHeadline[];
  etag: string;
};
export type OrgPlanning = {
  deadline: OrgTimestamp | null;
  scheduled: OrgTimestamp | null;
  closed: OrgTimestamp | null;
};
/**
 * OrgTimestamp represents an org-mode timestamp
 */
export type OrgTimestamp =
  | {
      Active: {
        start: OrgDatetime;
        repeater: string | null;
        delay: string | null;
      };
    }
  | {
      Inactive: {
        start: OrgDatetime;
        repeater: string | null;
        delay: string | null;
      };
    }
  | {
      ActiveRange: {
        start: OrgDatetime;
        end: OrgDatetime;
        repeater: string | null;
        delay: string | null;
      };
    }
  | {
      InactiveRange: {
        start: OrgDatetime;
        end: OrgDatetime;
        repeater: string | null;
        delay: string | null;
      };
    }
  | { Diary: { value: string } };
/**
 * Represents a headline title in org-mode
 */
export type OrgTitle = {
  raw: string;
  level: number;
  priority: string | null;
  tags: string[];
  todo_keyword: string | null;
  properties: Partial<{ [key in string]: string }>;
  planning: OrgPlanning | null;
};
/**
 * Structure to represent parse override for specific files
 */
export type ParseOverride = {
  /**
   * The file path
   */
  path: string;
  /**
   * Whether to parse this file
   */
  parse: boolean;
};
/**
 * Type of path being monitored
 */
export type PathType = "File" | "Directory";
export type StateType = "Active" | "Closed";
export type TodoConfiguration = {
  sequences: TodoSequence[];
  default_sequence: string;
};
export type TodoSequence = { name: string; statuses: TodoStatus[] };
export type TodoStatus = {
  keyword: string;
  state_type: StateType;
  order: number;
  color: string | null;
};
/**
 * Main user settings structure
 */
export type UserSettings = {
  /**
   * List of monitored paths
   */
  monitored_paths: MonitoredPath[];
  /**
   * Parse overrides for specific files
   */
  parse_overrides: ParseOverride[];
};

/** tauri-specta globals **/

import {
  invoke as TAURI_INVOKE,
  Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
  listen: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
  once: (
    cb: TAURI_API_EVENT.EventCallback<T>,
  ) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
  emit: null extends T
    ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
    : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
  | { status: "ok"; data: T }
  | { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
  mappings: Record<keyof T, string>,
) {
  return new Proxy(
    {} as unknown as {
      [K in keyof T]: __EventObj__<T[K]> & {
        (handle: __WebviewWindow__): __EventObj__<T[K]>;
      };
    },
    {
      get: (_, event) => {
        const name = mappings[event as keyof T];

        return new Proxy((() => {}) as any, {
          apply: (_, __, [window]: [__WebviewWindow__]) => ({
            listen: (arg: any) => window.listen(name, arg),
            once: (arg: any) => window.once(name, arg),
            emit: (arg: any) => window.emit(name, arg),
          }),
          get: (_, command: keyof __EventObj__<any>) => {
            switch (command) {
              case "listen":
                return (arg: any) => TAURI_API_EVENT.listen(name, arg);
              case "once":
                return (arg: any) => TAURI_API_EVENT.once(name, arg);
              case "emit":
                return (arg: any) => TAURI_API_EVENT.emit(name, arg);
            }
          },
        });
      },
    },
  );
}
